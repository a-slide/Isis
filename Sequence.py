from random import random
from random import randint
from random import betavariate
from string import maketrans
from pprint import pprint as pp
import matplotlib.pyplot as plt

class Sequence:
    """"""

########################################################################################################################
#   FONDAMENTAL METHODS
########################################################################################################################

    def __init__ (self):
        
        # Empty dictionnary to store biopython seqRecord
        self.seq_dict = {}
        
        # Strings containing allowed DNA bases
        self._DNA_strict = "ATCG"
        self._DNA_repeats = "ATCGatcg"
        self._DNA_ambigous = "ATCGKMRYSWBVHDN"
        self._DNA_ambigous_repeats = "ATCGKMRYSWBVHDNatcgkmryswbvhdn"
        
        # Complement table to generate DNA complementary strand
        self._complement_table = maketrans("AGCTYRWSKMDVHBNagctyrwskmdvhbn", "TCGARYWSMKHBDVNtcgarywsmkhbdvn")


########################################################################################################################
#   GETERS
########################################################################################################################

    # Give acces to the complete dictionary
    def getDict (self):
        return self.seq_dict

    # Give acces to individual values in conf_dict by using its key name.
    def getVar (self, varkey ):
        return self.seq_dict[varkey]


########################################################################################################################
#   ACTION METHODS
########################################################################################################################

    # TODO Catch exception in case no read was found
    # TODO PARRALELIZE READ Picking
    def generate_read_dict (self, nread, read_len, repeats = False, ambigous = False, duplicate = False,
                            pair = False, min = None, max = None, mean = None, certainty = None):
        """Generate a list of sequence containg the name (with localisation in mother sequence) size and DNA sequence"""
        
        read_dict = {}
        alpha = beta = ndup = nfail = i = 0 # Counter allowing to iterate in case 
        
        # Calculate the parameters of shape for the beta distribution to mimick DNA shearing distribution by sonication
        if pair:
            alpha, beta = self._beta_shape(min, max, mean, certainty)
        
        while i < nread:
            # Try to generate a valid read. Return a list with name, length [+frag size if pair], sequence [both if pair]
            read = self._generate_read (read_len, repeats, ambigous, pair, alpha, beta, min, max)
            
            # In case it is impossible to generate a valid read in seq_dict
            if not read:
                nfail +=1
                # if the number of fail to generate reads is low try to resample
                if nfail < nread:
                        continue
                    # If the maximal number of faillure when trying to generate reads was exceded break
                    break
            
            # If the dictionnary already contains this entry (same sequence name)
            if read[0] in read_dict:
                ndup +=1
                
                # If duplicates are not allowed
                if not duplicate:
                    # If the maximal number of tries to generate non duplicated reads is low try to resample
                    if ndup < nread:
                        continue
                    # If the maximal number of tries to generate non duplicated reads was exceded break out the loop  
                    break
                    
                # If duplicates are allowed
                else:
                    # Adding a number to the name (starting at 2) and checking if the new name is non in dict
                    for j in range (ndup):
                        name = '{0}_{1}'.format(read[0], j+1)
                        if name not in read_dict:
                            read[0] = name
                            break
                            
            # Finaly if the read was already in dict or if it was renamed add a new entry in dict
            read_dict[read[0]] = read[1:]
            i+=1
        
        len_dict = len(read_dict)
        self._out_message(duplicate, ndup, nread, len_dict)
        
        if pair and len_dict != 0:
            self._draw_distribution(read_dict)
        
        return read_dict
        

########################################################################################################################
#   PRIVATE METHODS
########################################################################################################################      
    
    
    # TODO create an Exception in case no read was found
    def _generate_read (self, read_len, repeats, ambigous, pair, alpha = None, beta = None, min = None, max = None):
        """Generate a candidate read or read pair of a given lenght with or without repeats and ambigous DNA bases"""
        
        # Guard condition if not possible to find a valid pair after 10 tries
        for count in range (10):
            
            # Pick a random sequence in dictionnary proportionally to its length
            ref_seq = self._random_seq ()
            
            # Generate a pseudo-random size resulting from sonication for paired-end reads
            if pair:
                frag_len = self._beta_distrib(alpha, beta, min, max)
            # For single read just use the size of one read
            else:
                frag_len = read_len
            
            # Start again if the choosen reference sequence is shorter than the lenght of the fragment to be sampled
            if len(self.seq_dict[ref_seq].seq) < frag_len :
                continue
                
            # Define a random position in the reference sequence and sample a candidate region
            candidate_seq = self._random_candidate_sequence (ref_seq, frag_len)
            
            # Verify the validity of the candidate sequence in terms of repeats and ambiguity
            if self._valid(candidate_seq[2], repeats, ambigous):
                
                # Both extremities of candidate are sampled for pair end
                if pair:
                    return self._extract_pair(candidate_seq, read_len, frag_len)
                # For single end the whole fragment is returned
                else:
                    return candidate_seq
                    
        print ("\nNo valid read found")
        return None
    
    
    def _random_seq (self):
        """Pick a random sequence in seq_dict. Usage is different for subclasses"""
        pass
                
                
    def _random_candidate_sequence(self, refseq, size):
        """Return a list with [refseq name+startpos+endpos, size, sequence]"""
        startpos = randint (0, self.seq_dict[refseq][0]-size)
        sequence = self.seq_dict[refseq][1][startpos:startpos+size]
        
        # Randomly choose an orientation reverse or forward for the fragment
        if randint(0,1):
            name = '{0}_{1}-{2}'.format(refseq, startpos, startpos+size)
        else:
            name = '{0}_{1}-{2}'.format(refseq, startpos+size, startpos)
            sequence = self._rc(sequence)
            
        return [name, size, sequence]
        
        
    def _valid (self, seq, repeats, ambigous):
        """Define if the candidate region is valid according to user specifications (allow repeats, allow ambigous)"""
        if not repeats:
            if not ambigous:
                # no repeats and no ambigous DNA base
                return self._valid_region(seq, self._DNA_strict)
            else:
                # no repeats but ambigous DNA base
                return self._valid_region(seq, self._DNA_ambigous)
        else:
            if not ambigous:
                # Repeats but no ambigous DNA base
                return self._valid_region(seq, self._DNA_repeats)
            else:
                # Repeats and ambigous DNA base
                return self._valid_region(seq, self._DNA_ambigous_repeats)
                
                
    def _valid_region(self, seq, alphabet):
        # determine if the sequence contains only the letters in alphabet
        
        # if any of seq characters are not in the alphabet = return false
        for i in seq:
            if i not in alphabet:
                return False
        
        # If all characters of seq are in the alphabet = return true
        return True
        
        
    def _rc (self, sequence):
        """Return the reverse complementary of any DNA sequence"""
        return sequence.translate(self._complement_table)[::-1]
        
        
    def _beta_shape(self,min, max, mean, k):
        """Calculate shape parameters alpha and beta to fit experimental indication from user"""
        mode = float((mean - min)) / (max - min)
        a = mode *(k-2) + 1
        b = k - a
        return (a, b)
        
        
    def _beta_distrib(self, a, b, min, max):
        """Define a pseudorandom size according to a beta distribution giving alpha and beta"""
        return int(betavariate(a,b)*(max-min) + min)
        
        
    def _extract_pair(self, candidate_seq, read_len, frag_len):
        """Extract reads forward and reverse from a candidate sequence and return a list with name,read size, frag length and both sequences"""
        forward_read = candidate_seq[2][0:read_len]
        reverse_read = self._rc(candidate_seq[2][-read_len:])
        return [candidate_seq[0], read_len, frag_len, forward_read, reverse_read]
        
                
    def _out_message (self, duplicate, ndup, nread, len_dict):
        """ Print an output massage according to the success or failure to generate the required sequences"""
        
        if len_dict == 0:
            print ('\nThe dictionnary is empty. Paramaters or reference sequences are not suitable')
        elif len_dict < nread:
            print ('\nImpossible to generate the required number of reads ({0}). The dictionnary contains only {1} entries'.format(nread, len_dict))
        elif duplicate and ndup >=1 :
            print ('\nThe dictionnary contains the required number of sequences ({0}) but includes {1} duplicate(s)'.format(len_dict, ndup))
        else:
            print ('\nThe dictionnary contains the required number of sequences ({0}) and no duplicate'.format(len_dict))
        
        
    def _draw_distribution(self, read_dict):
        """Use Pyplot histogram function to draw an histogram of fragment size distribution"""
        list_len = []
        # Extract frag_len from read_dict and append them in the liste
        for val in read_dict.values():
            list_len.append(val[0][1])
        
        # Represent data with an histogramm using pyplot
        h = plt.hist(list_len, bins = 100, normed = True)
        plt.show()



########################################################################################################################


########################################################################################################################


########################################################################################################################



class Reference (Sequence):

########################################################################################################################
#   FONDAMENTAL METHODS
########################################################################################################################

    def __init__(self):
        """Object constructor importing reference sequences from fasta file"""
        super().__init__()
        
        # Dictionnary of sequences storing name, size and sequence string
        self.seq_dict = self._create_seq_dict(filename)

        # List cummulative probabilities of each sequence to be picked calculated from to their respective size.
        self.proba_list = self._calculate_proba()
    
    def __repr__(self):
        result = "<Instance of Reference(Sequence)>\n"
        for key, value in self.seq_dict.items():
            result += "<{0}\tSize : {1}\tSequence : {2}...{3}>\n".format(key, value[0], value[1][:10], value[1][-10:])
        
        return result

    def __str__(self):
        return "<Instance of Reference(Sequence)>\n"
    
    
########################################################################################################################
#   GETERS
########################################################################################################################

    # Give acces to the cummulative frequency list
    def getProba (self):
        return self.proba_list


########################################################################################################################
#   ACTION METHODS
########################################################################################################################


########################################################################################################################
#   PRIVATE METHODS
########################################################################################################################
    
    def _import_seq_dict(self, filename):
        """Import fasta files in a dictionary of biopython SeqRecord"""

        try: # try to open the file
            if filename.rpartition(".")[-1] == "gz":
                print ("Uncompressing and extracting data")
                handle = gzip.open(filename, "r")
            else:
                print ("Extracting data")
                handle = open(filename, "r")

            seq_dict = SeqIO.to_dict(SeqIO.parse( handle, "fasta"))
            handle.close()
            return seq_dict
            
        except IOError:
               print ('CRITICAL ERROR. The fasta file ' + filename + ' is not readable. Exit')
               exit


    def _calculate_proba(self):
        """Return a 2 entries list / 1 = name of the sequence / 2 = cumulative frequency of the sequence"""
        cumulative_len = 0

        # Calculate the cumulative length for all seq in seq_dict
        for record in self.seq_dict.values():
            cumulative_len += len(record.seq)

        # Calculate a cumulative frequency for all reference sequences and return the list of frequencies
        return [[record.name, float(len(record.seq))/cumulative_len] for record in self.seq_dict.values()]


    def _random_seq (self):
        """Return a random sequence from seq_dict according the respective size of references"""

        # Define a pseudo-random decimal frequency
        rand_freq = random()
        
        # Attibute this frequency to a sequence from seq_dict based on proba_list
        for name, freq  in self.proba_list:
            if freq > rand_freq :
                return name
                
